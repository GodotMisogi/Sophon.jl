# Helmholtz equation

Let us consider the Helmholtz equation in two space dimensions

```math
\begin{aligned}
&\Delta u(x, y)+k^{2} u(x, y)=q(x, y), \quad(x, y) \in \Omega:=(-1,1) \\
&u(x, y)=h(x, y), \quad(x, y) \in \partial \Omega
\end{aligned}
```
where 
```math 
q(x, y)=-\left(a_{1} \pi\right)^{2} \sin \left(a_{1} \pi x\right) \sin \left(a_{2} \pi y\right)-\left(a_{2} \pi\right)^{2} \sin \left(a_{1} \pi x\right) \sin \left(a_{2} \pi y\right)+k^{2} \sin \left(a_{1} \pi x\right) \sin \left(a_{2} \pi y\right).
```
The excat solution is ``u(x,y)=\sin{a_1\pi x}\sin{a_2\pi y}``. We chose ``k=1, a_1 = 1`` and ``a_2 = 4``.

```julia
using NeuralPDE, IntervalSets, Sophon, Lux, Random, NNlib
using Optimization, OptimizationOptimisers, OptimizationOptimJL
using Statistics: mean

@parameters x,y
@variables u(..)
Dxx = Differential(x)^2
Dyy = Differential(y)^2

q(x,y) = -π^2 * sin(π*x) * sin(4*π*y) - 16*π^2 * sin(π*x) * sin(4*π*y) +  sin(π*x) * sin(4*π*y)

eq = Dxx(u(x,y)) + Dyy(u(x,y)) + u(x,y) ~ q(x,y)
domain = [x ∈ -1..1, y ∈ -1..1]
bcs = [u(-1,y) ~ 0, u(1,y) ~ 0, u(x, -1) ~ 0, u(x, 1) ~ 0]

@named pde = PDESystem(eq, bcs, domain, [x,y], [u(x,y)])

chain = PINNAttention(2, 50, 4,)
ps, _ = Lux.setup(Random.default_rng(), chain)
ps = ps |> ComponentArray |> gpu .|> Float64
discretization = PhysicsInformedNN(chain, GridTraining(0.01); 
                                   adaptive_loss = NonAdaptiveLoss(bc_loss_weights = 5),
                                   init_params = ps)
prob = discretize(pde, discretization)
phi = discretization.phi

callback = function (p, l)
    println("Current loss is: $l")
    return false
end
res = Optimization.solve(prob, Adam(5f-2); maxiters=2000, callback=callback)

prob = remake(prob; u0=res.u)
println("Training with BFGS")
res = Optimization.solve(prob, LBFGS(); maxiters=100, callback=callback)

xs, ys= [infimum(d.domain):0.01:supremum(d.domain) for d in domain]
x_mesh = NNlib.unsqueeze(xs .* ones(length(ys))')
y_mesh = NNlib.unsqueeze(ones(length(xs)) .* ys')

analytic(x,y) = sin(pi*x)*sin(4*pi*y)
u_real = analytic.(x_mesh, y_mesh)
u_real = reshape(u_real, length(xs), length(ys))
u_pred = phi(vcat(x_mesh,y_mesh), res.u)
u_pred = reshape(u_pred, length(xs), length(ys))

using CairoMakie
axis = (xlabel="x", ylabel="y", title="Analytical Solution")
fig, ax1, hm1 = heatmap(xs, ys, u_real, axis=axis)
Colorbar(fig[:, end+1], hm1)
ax2, hm2= heatmap(fig[1, end+1], xs, ys, u_pred, axis= merge(axis, (;title = "Prediction")))
Colorbar(fig[:, end+1], hm2)
ax3, hm3 = heatmap(fig[1, end+1], xs, ys, abs.(u_pred-u_real), axis= merge(axis, (;title = "Absolute Error")))
Colorbar(fig[:, end+1], hm3)

display(fig)
```

```julia
print("MSE error", mean(abs, (u_pred-u_real)))
```

